///Zero Indexed
///F=(x_0 or y_0) and (x_1 or y_1) and ... (x_{vars-1} or y_{vars-1})
///here y_i belongs to x_i
///is there any assignment of x_i such that F=true
///for (x_0 xor y_0) and (x_1 xor y_1)...
///replace (x_i xor y_i) by (x_i or y_i) and (not x_i or not y_i)
struct twosat {
	int n;	/// total size combining +, -. must be even.
	vector< vector<int> > g, gt;	/// graph, transpose graph
	vector<bool> vis, res;	/// visited and resulting assignment
	vector<int> comp;	/// component number
	stack<int> ts;	/// topsort
 
	twosat(int vars=0) {
		n = (vars << 1);
		g.resize(n);
		gt.resize(n);
	}
 
	/// zero indexed, be careful
	/// (x_a or (not x_b))-> af=1,bf=0
	void add(int a, bool af, int b, bool bf) {
		a += a+(af^1);
		b += b+(bf^1);
		g[a^1].push_back(b);	/// !a => b
		g[b^1].push_back(a);	/// !b => a
		gt[b].push_back(a^1);
		gt[a].push_back(b^1);
	}
 
	void dfs1(int u) {
		vis[u] = true;
		for(int v : g[u]) if(!vis[v]) dfs1(v);
		ts.push(u);
	}
 
	void dfs2(int u, int c) {
		comp[u] = c;
		for(int v : gt[u]) if(comp[v] == -1) dfs2(v, c);
	}
	bool ok() {
		vis.resize(n, false);
		for(int i=0; i<n; ++i) if(!vis[i]) dfs1(i);
 
		int scc = 0;
		comp.resize(n, -1);
		while(!ts.empty()) {
			int u = ts.top();
			ts.pop();
			if(comp[u] == -1) dfs2(u, scc++);
		}
 
		res.resize(n/2);
		for(int i=0; i<n; i+=2) {
			if(comp[i] == comp[i+1]) return false;
			res[i/2] = (comp[i] > comp[i+1]);
		}
		return true;
	}
};
