struct Lift{
    ll n;
    vector<array<int32_t, 20>> lift;
    vector<int32_t> dpth;
    vector<int32_t> tin,tout;
    int t;
    Lift(const vector<vector<ll>> &adj,ll N) {
        n = N;
        lift.resize(n+1);
        dpth.resize(n+1);
        tin.resize(n+1);
        tout.resize(n+1);
        fill(all(dpth), 0);
        for(ll i = 1 ; i <= n ; i++)    lift[i].fill(0);
        t=0;
        dfs(1, 0, adj);
        for(ll j = 1 ; j < 20 ; j++) {
            for(ll i = 1 ; i <= n ; i++) {
                lift[i][j] = lift[lift[i][j-1]][j - 1];
            }
        }
    }
    void dfs(ll i, ll p, const vector<vector<ll>> &adj) {
        tin[i]=++t;
        lift[i][0] = p;
        for(auto &u: adj[i]) {
            if(u == p)  continue;
            dpth[u] = dpth[i] + 1;
            dfs(u, i, adj);
        }tout[i]=t;
    }
    ll kthanc(ll node, ll d) {
        for(ll i = 0 ; i < 20 ; i++) {
            if((d >> i) & 1) node = lift[node][i];
        }
        return node;
    }
    bool is_ancestor(ll u,ll v){
        return tin[u]<=tin[v] and tout[u]>=tout[v];
    }
    ll lca(ll x, ll y) {
        if(dpth[x] > dpth[y])   swap(x, y);
        y = kthanc(y, dpth[y] - dpth[x]);
        if(x == y)  return x;
        for(ll i = 19 ; i >= 0 ; i--) {
            if(lift[y][i] != lift[x][i])    x = lift[x][i], y = lift[y][i];
        }
        return lift[x][0];
    }
    ll dist(ll x, ll y) {
        return dpth[x] + dpth[y] - 2 * dpth[lca(x, y)];
    }
};
